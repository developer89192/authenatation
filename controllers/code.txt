controllers/

authController.js :

// authController.js

import axios from 'axios';
import jwt from 'jsonwebtoken';
import { createClient } from 'redis';
import { generateTokens } from '../utils/tokenUtils.js';
import User from '../models/User.js';
import {
  API_KEY,
  OTP_EXPIRY,
  MAX_VERIFICATION_ATTEMPTS,
  JWT_SECRET,
  JWT_REFRESH_SECRET,
} from '../config.js';

// Redis Cloud Client Configuration
const redisClient = createClient({
  username: 'default',
  password: 'fA2YBZIANbdCkUtIBqaHw1hmBnu0ArYh',
  socket: {
    host: 'redis-16607.c212.ap-south-1-1.ec2.redns.redis-cloud.com',
    port: 16607,
  },
});

redisClient.on('error', (err) => console.log('❌ Redis Client Error:', err));
await redisClient.connect();
console.log('✅ Connected to Redis Cloud');

// Generate a 6-digit OTP
function generateOtp() {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

// SEND OTP
export const sendOtp = async (req, res, next) => {
  try {
    const { mobileNumber } = req.body;

    if (!mobileNumber) return res.status(400).json({ error: 'Mobile number is required' });

    let user = await User.findOne({ mobile_number: mobileNumber });
    if (!user) {
      user = await User.create({ mobile_number: mobileNumber });
    }

    const otpKey = `otp:${mobileNumber}`;
    const attemptsKey = `otp_attempts:${mobileNumber}`;

    const existingOtp = await redisClient.get(otpKey);
    if (existingOtp) {
      return res.status(429).json({ error: 'OTP already sent. Please wait 5 minutes to resend.' });
    }

    const otp = generateOtp();
    await redisClient.setEx(otpKey, OTP_EXPIRY || 300, otp);
    await redisClient.setEx(attemptsKey, OTP_EXPIRY || 300, '0');

    const message = `Your OTP is ${otp}. It is valid for 5 minutes.`;

    try {
      await axios.post(
        'http://localhost:5000/receive-otp',
        new URLSearchParams({
          message,
          language: 'english',
          route: 'q',
          numbers: mobileNumber,
        }),
        {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            // 'authorization': API_KEY,
          },
        }
      );

      res.json({ success: true, message: 'OTP sent successfully' });
    } catch (err) {
      await redisClient.del(otpKey);
      res.status(500).json({ error: 'Failed to send OTP', details: err.message });
    }
  } catch (error) {
    next(error);
  }
};

// VERIFY OTP
export const verifyOtp = async (req, res, next) => {
  try {
    const { mobileNumber, code } = req.body;

    if (!mobileNumber || !code) {
      return res.status(400).json({ error: 'Mobile number, verification ID and OTP code are required' });
    }

    const otpKey = `otp:${mobileNumber}`;
    const attemptsKey = `otp_attempts:${mobileNumber}`;

    const savedOtp = await redisClient.get(otpKey);
    if (!savedOtp) return res.status(400).json({ error: 'OTP expired or not found' });

    if (code !== savedOtp) {
      let attempts = parseInt(await redisClient.get(attemptsKey)) || 0;
      attempts++;

      if (attempts >= (MAX_VERIFICATION_ATTEMPTS || 3)) {
        await redisClient.del(otpKey);
        await redisClient.del(attemptsKey);
        return res.status(403).json({ error: 'Too many failed attempts. OTP has expired.' });
      }

      await redisClient.setEx(attemptsKey, OTP_EXPIRY || 300, attempts.toString());
      return res.status(400).json({ error: 'Incorrect OTP', attemptsLeft: (MAX_VERIFICATION_ATTEMPTS || 3) - attempts });
    }

    await redisClient.del(otpKey);
    await redisClient.del(attemptsKey);

    const user = await User.findOneAndUpdate(
      { mobile_number: mobileNumber },
      {
        is_verified: true,
        $push: { login_dates: new Date() },
      },
      { new: true }
    );

    const { accessToken, refreshToken } = generateTokens(user._id);

    user.refresh_token = refreshToken;
    await user.save();

    res
      .cookie('access_token', accessToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 15 * 60 * 1000,
      })
      .cookie('refresh_token', refreshToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000,
      })
      .json({ success: true, message: 'OTP verified successfully', userId: user._id });
  } catch (error) {
    console.error('OTP verification failed:', error.message);
    next(error);
  }
};

// REFRESH TOKEN
export const refreshToken = async (req, res, next) => {
  try {
    const { refresh_token } = req.cookies;
    if (!refresh_token) return res.sendStatus(401);

    const payload = jwt.verify(refresh_token, JWT_REFRESH_SECRET);
    const user = await User.findById(payload.id);
    if (!user || user.refresh_token !== refresh_token) {
      return res.sendStatus(403);
    }

    const { accessToken, refreshToken: newRefreshToken } = generateTokens(user._id);
    user.refresh_token = newRefreshToken;
    await user.save();

    res
      .cookie('access_token', accessToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 15 * 60 * 1000,
      })
      .cookie('refresh_token', newRefreshToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000,
      })
      .json({ message: 'Token refreshed' });
  } catch (err) {
    next(err);
  }
};

// LOGOUT
export const logout = async (req, res, next) => {
  try {
    const { refresh_token } = req.cookies;
    if (refresh_token) {
      await User.findOneAndUpdate(
        { refresh_token },
        { $unset: { refresh_token: '' } }
      );
    }

    res
      .clearCookie('access_token')
      .clearCookie('refresh_token')
      .json({ message: 'Logged out' });
  } catch (error) {
    next(error);
  }
};


middlewares/

authMiddleware.js :

import jwt from 'jsonwebtoken';  // Change require to import for jwt
import User from '../models/User.js';  // Ensure correct import for User model (note the .js extension)
import { JWT_SECRET } from '../config.js';  // Ensure correct import for JWT_SECRET (note the .js extension)

const authenticate = async (req, res, next) => {
  const token = req.cookies.access_token;
  if (!token) return res.status(401).json({ message: 'Access Denied' });

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    const user = await User.findById(decoded.id).select('-refresh_token');
    if (!user) return res.status(404).json({ message: 'User not found' });

    req.user = user;
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Invalid or Expired Token' });
  }
};

// Use default export for ES modules
export default authenticate;




csrfMiddleware.js :

import csrf from 'csurf'; // Use import for csrf
import cookieParser from 'cookie-parser'; // Use import for cookie-parser

const csrfProtection = csrf({ cookie: true }); // No change needed here


module.exports = {
  csrfProtection,
  cookieParser,
};


errorMiddleware.js :

const errorHandler = (err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    message: err.message || 'Internal Server Error',
    stack: process.env.NODE_ENV === 'production' ? null : err.stack,
  });
};

export { errorHandler }; // ES module export


rateLimiter.js :

import rateLimit from 'express-rate-limit'; // ES Module import for express-rate-limit

const otpRateLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 3, // limit each phone to 3 OTP requests per windowMs
  message: 'Too many OTP requests, please try again later.',
  keyGenerator: (req) => req.body.mobileNumber || req.ip,
});

export default otpRateLimiter; // ES module export default

models/

User.js :

import mongoose from 'mongoose'; // ES Module import for mongoose

const userSchema = new mongoose.Schema({
  mobile_number: { type: String, required: true, unique: true },
  name: { type: String, default: '' },
  email: { type: String, default: '' },
  primary_address: { type: String, default: '' },
  secondary_addresses: [{ type: String }],
  updated_at: [{ type: Date }],
  login_dates: [{ type: Date }],
  account_created_at: { type: Date, default: Date.now },
  is_verified: { type: Boolean, default: false },
  refresh_token: { type: String }, // Optional if you're storing it in DB
});

export default mongoose.model('User', userSchema); // ES Module export default


routes /

authRoutes.js :
import express from 'express'; // ES Module import for express
import { sendOtp, verifyOtp, refreshToken, logout } from '../controllers/authController.js'; // ES Module imports for controller functions

const router = express.Router();

router.post('/send-otp', sendOtp);
router.post('/verify-otp', verifyOtp);
router.post('/refresh-token', refreshToken);
router.post('/logout', logout);

export default router; // ES Module export default


userRoutes.js :

// routes/userRoutes.js
import express from 'express'; // ES Module import for express
import authenticate from '../middlewares/authMiddleware.js'; // ES Module import for the middleware

const router = express.Router();

// GET /user/me — Get current logged-in user's data
router.get('/me', authenticate, (req, res) => {
  res.json(req.user); // populated by auth middleware
});

export default router; // ES Module export default


utils /

tokenUtils.js :

import jwt from 'jsonwebtoken'; // ES Module import for jwt
import { JWT_SECRET, JWT_REFRESH_SECRET } from '../config.js'; // ES Module import for config

export const generateTokens = (userId) => {
  const accessToken = jwt.sign({ id: userId }, JWT_SECRET, { expiresIn: '15m' });
  const refreshToken = jwt.sign({ id: userId }, JWT_REFRESH_SECRET, { expiresIn: '7d' });

  return { accessToken, refreshToken };
};


app.js :

import express from 'express'; // ES Module import for express
import cookieParser from 'cookie-parser'; // ES Module import for cookie-parser
import cors from 'cors'; // ES Module import for cors
import csrf from 'csurf'; // ES Module import for csrf

import authRoutes from './routes/authRoutes.js'; // ES Module import for authRoutes
import userRoutes from './routes/userRoutes.js'; // ES Module import for userRoutes
import { errorHandler } from './middlewares/errorMiddleware.js'; // ES Module import for errorHandler

const app = express();
app.use(cors({
  origin: 'http://localhost:5173', // change to your frontend URL
  credentials: true,
}));
app.use(express.json());
app.use(cookieParser());

// CSRF protection
// const csrfProtection = csrf({ cookie: true });
// app.use(csrfProtection);

// Routes
app.use('/auth', authRoutes);
app.use('/user', userRoutes);

// Error handling middleware
app.use(errorHandler);

export default app; // ES Module export default

 


