const axios = require('axios');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const { createClient } = require('redis');
const { generateTokens } = require('../utils/tokenUtils');
const {
  API_KEY, // Fast2SMS API Key
  OTP_EXPIRY = 300, // 5 minutes in seconds
  MAX_VERIFICATION_ATTEMPTS = 3,
  JWT_SECRET,
  JWT_REFRESH_SECRET
} = require('../config');

// Redis Cloud Client Configuration
const redisClient = createClient({
  username: 'default',
  password: 'fA2YBZIANbdCkUtIBqaHw1hmBnu0ArYh', // Redis Cloud password
  socket: {
    host: 'redis-16607.c212.ap-south-1-1.ec2.redns.redis-cloud.com',
    port: 16607,
  }
});

redisClient.on('error', (err) => console.log('❌ Redis Client Error:', err));
await redisClient.connect();
console.log('✅ Connected to Redis Cloud');

// Generate a 6-digit OTP
function generateOtp() {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

// SEND OTP
exports.sendOtp = async (req, res, next) => {
  try {
    const { mobileNumber } = req.body;

    if (!mobileNumber) return res.status(400).json({ error: 'Mobile number is required' });

    let user = await User.findOne({ mobile_number: mobileNumber });
    if (!user) {
      user = await User.create({ mobile_number: mobileNumber });
    }

    const otpKey = `otp:${mobileNumber}`;
    const attemptsKey = `otp_attempts:${mobileNumber}`;

    // Check if OTP already sent within expiry period
    const existingOtp = await redisClient.get(otpKey);
    if (existingOtp) {
      return res.status(429).json({ error: 'OTP already sent. Please wait 5 minutes to resend.' });
    }

    const otp = generateOtp();

    // Store OTP in Redis with expiry (5 minutes)
    await redisClient.setEx(otpKey, OTP_EXPIRY, otp);
    await redisClient.setEx(attemptsKey, OTP_EXPIRY, '0'); // Reset attempts count

    const message = `Your OTP is ${otp}. It is valid for 5 minutes.`;

    try {
      // Send OTP via Fast2SMS
      await axios.post(
        "http://localhost:5000/receive-otp",  // Replace with actual Fast2SMS endpoint
        new URLSearchParams({
          message,
          language: 'english',
          route: 'q',
          numbers: mobileNumber
        }),
        {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            // 'authorization': API_KEY, // Uncomment for actual use
          }
        }
      );

      res.json({ success: true, message: 'OTP sent successfully' });
    } catch (err) {
      // If sending OTP fails, delete OTP and reset attempts in Redis
      await redisClient.del(otpKey);
      res.status(500).json({ error: 'Failed to send OTP', details: err.message });
    }
  } catch (error) {
    next(error);
  }
};

// VERIFY OTP
exports.verifyOtp = async (req, res, next) => {
  try {
    const { mobileNumber, verificationId, code } = req.body;

    if (!mobileNumber || !verificationId || !code) {
      return res.status(400).json({ error: 'Mobile number, verification ID and OTP code are required' });
    }

    const otpKey = `otp:${mobileNumber}`;
    const attemptsKey = `otp_attempts:${mobileNumber}`;

    // Check if OTP is stored in Redis
    const savedOtp = await redisClient.get(otpKey);
    if (!savedOtp) return res.status(400).json({ error: 'OTP expired or not found' });

    // If OTP is incorrect, increment the verification attempts
    if (code !== savedOtp) {
      let attempts = parseInt(await redisClient.get(attemptsKey)) || 0;
      attempts++;

      if (attempts >= MAX_VERIFICATION_ATTEMPTS) {
        // Too many failed attempts, delete OTP and reset attempts in Redis
        await redisClient.del(otpKey);
        await redisClient.del(attemptsKey);
        return res.status(403).json({ error: 'Too many failed attempts. OTP has expired.' });
      }

      // Update the failed attempts count in Redis
      await redisClient.setEx(attemptsKey, OTP_EXPIRY, attempts.toString());
      return res.status(400).json({ error: 'Incorrect OTP', attemptsLeft: MAX_VERIFICATION_ATTEMPTS - attempts });
    }

    // OTP verified successfully, clear OTP and attempts in Redis
    await redisClient.del(otpKey);
    await redisClient.del(attemptsKey);

    // Update the user's verification status and login dates
    const user = await User.findOneAndUpdate(
      { mobile_number: mobileNumber },
      { 
        is_verified: true,
        $push: { login_dates: new Date() },
      },
      { new: true }
    );

    // Generate JWT tokens
    const { accessToken, refreshToken } = generateTokens(user._id);

    // Save refresh token to user
    user.refresh_token = refreshToken;
    await user.save();

    res
      .cookie('access_token', accessToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 15 * 60 * 1000, // 15 minutes
      })
      .cookie('refresh_token', refreshToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      })
      .json({ success: true, message: 'OTP verified successfully', userId: user._id });
  } catch (error) {
    console.error('OTP verification failed:', error.message);
    next(error);
  }
};

// REFRESH TOKEN
exports.refreshToken = async (req, res, next) => {
  try {
    const { refresh_token } = req.cookies;
    if (!refresh_token) return res.sendStatus(401);

    const payload = jwt.verify(refresh_token, JWT_REFRESH_SECRET);
    const user = await User.findById(payload.id);
    if (!user || user.refresh_token !== refresh_token) {
      return res.sendStatus(403);
    }

    const { accessToken, refreshToken } = generateTokens(user._id);
    user.refresh_token = refreshToken;
    await user.save();

    res
      .cookie('access_token', accessToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 15 * 60 * 1000,
      })
      .cookie('refresh_token', refreshToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000,
      })
      .json({ message: 'Token refreshed' });
  } catch (err) {
    next(err);
  }
};

// LOGOUT
exports.logout = async (req, res, next) => {
  try {
    const { refresh_token } = req.cookies;
    if (refresh_token) {
      const user = await User.findOneAndUpdate(
        { refresh_token },
        { $unset: { refresh_token: "" } }
      );
    }

    res
      .clearCookie('access_token')
      .clearCookie('refresh_token')
      .json({ message: 'Logged out' });
  } catch (error) {
    next(error);
  }
};






















-----------------------------



const axios = require('axios');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const {
  CPAAS_URL,
  CPAAS_CUSTOMER_ID,
  CPAAS_AUTH_TOKEN,
  JWT_SECRET,
  JWT_REFRESH_SECRET,
} = require('../config');
const { generateTokens } = require('../utils/tokenUtils');

exports.sendOtp = async (req, res, next) => {
  try {
    const { mobileNumber } = req.body;

    let user = await User.findOne({ mobile_number: mobileNumber });
    if (!user) {
      user = await User.create({ mobile_number: mobileNumber });
    }

    const response = await axios.post(
      `${CPAAS_URL}/send?countryCode=91&customerId=${CPAAS_CUSTOMER_ID}&flowType=SMS&mobileNumber=${mobileNumber}`,
      {},
      { headers: { authToken: CPAAS_AUTH_TOKEN } }
    );

    res.json(response.data);
  } catch (error) {
    next(error);
  }
};

   
exports.verifyOtp = async (req, res, next) => {
  try {
    const { mobileNumber, verificationId, code } = req.body;

    const url = `${CPAAS_URL}/validateOtp?countryCode=91&mobileNumber=${mobileNumber}&verificationId=${verificationId}&customerId=${CPAAS_CUSTOMER_ID}&code=${code}`;

    const response = await axios.request({
      method: 'GET',
      url: url,
      headers: {
        authToken: CPAAS_AUTH_TOKEN
      }
    });

    const verificationData = response.data.data;

    if (
      !verificationData ||
      verificationData.verificationStatus !== 'VERIFICATION_COMPLETED'
    ) {
      return res.status(401).json({
        message: 'OTP verification failed',
        providerMessage: response.data.message,
        providerCode: response.data.responseCode
      });
    }

    const user = await User.findOneAndUpdate(
      { mobile_number: mobileNumber },
      {
        is_verified: true,
        $push: { login_dates: new Date() },
      },
      { new: true }
    );

    const { accessToken, refreshToken } = generateTokens(user._id);

    user.refresh_token = refreshToken;
    await user.save();

    res
      .cookie('access_token', accessToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 15 * 60 * 1000,
      })
      .cookie('refresh_token', refreshToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000,
      })
      .json({ message: 'OTP verified', userId: user._id });
  } catch (error) {
    console.error('OTP verification failed:', error.response?.data || error.message);
    next(error);
  }
};









exports.refreshToken = async (req, res, next) => {
  try {
    const { refresh_token } = req.cookies;
    if (!refresh_token) return res.sendStatus(401);

    const payload = jwt.verify(refresh_token, JWT_REFRESH_SECRET);
    const user = await User.findById(payload.id);
    if (!user || user.refresh_token !== refresh_token) {
      return res.sendStatus(403);
    }

    const { accessToken, refreshToken } = generateTokens(user._id);
    user.refresh_token = refreshToken;
    await user.save();

    res
      .cookie('access_token', accessToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 15 * 60 * 1000,
      })
      .cookie('refresh_token', refreshToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000,
      })
      .json({ message: 'Token refreshed' });
  } catch (err) {
    next(err);
  }
};

exports.logout = async (req, res, next) => {
  try {
    const { refresh_token } = req.cookies;
    if (refresh_token) {
      const user = await User.findOneAndUpdate(
        { refresh_token },
        { $unset: { refresh_token: "" } }
      );
    }

    res
      .clearCookie('access_token')
      .clearCookie('refresh_token')
      .json({ message: 'Logged out' });
  } catch (error) {
    next(error);
  }
};
